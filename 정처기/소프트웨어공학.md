## 소프트웨어 개발 방법론
### 종류
- 구조적 방법론 : 절차지향적
- 정보공학 방법론 : 기업의 경영전략
- 객체지향 개발 방법론 : 개체, 속성, 메서드
- CBD : 재사용가능한 컴포넌트 개발 또는 상용 컴포넌트 조합
- 애자일 방법론 
### 개발 모델
- 폭포수 모델 
- 프로토 타이핑 
- 나선형 모델 : 계 위 개 고 (계획 및 요구 분석, 위험분석, 개발, 고객 평가)
- RAD 
- v 모형 : 폭포수모델 ~ 단위, 통합, 시스템, 인수 
### 애자일 방법론
- 개념 : 신속하고 반복적인 작업을 통해 지속적으로 작동 가능한 소프트웨어를 개발
- 방법론 
    1. XP 
        - 핵심가치 : 용기, 단순성, 의사소통, 피드백, 존중
        - 실천사항 : 짝 프로그래밍, 계획 세우기, TestDrivenDevelopment, 고객 상주, 지속적인 통합, 코드 개선, 작은 릴리즈, 코딩 표준, 공동 코드 소유, 간단한 디자인, 시스템 메타포어, 작업시간 준수
    2. 스크럼 
        - 백로그
        - 스프린트
    3. 그 외 | 크리스털(규모와 영향), FDD(기능주도), ASD(합동 애플리케이션 개발), 린(도요타 린)
### IT 서비스 관리
1. SLM : 서비스 수준, 관리 활동
2. SLA : 서비스 수준 정의 문서
3. ITSM : it 서비스의 일련의 정책과 관행
4. ITIL : IT서비스 가이드

## 계획
### 프로젝트 관리
- 프로젝트 핵심 관리대상 : People, Problem, Process
- PMBOK : 착수 - 계획 - 실행 - 통제 - 종료
### 개발 비용 산정
- 하향식 산정 기법 : 전문가 판단 기법, 델파이 기법
- 상향식 산정 기법 : LOC ((낙관치 + 4*중간치 + 비관치) / 6), 개발 단계별 노력
- 수학적 기법
    1. COCOMO
        - 조직형(Organic, 5만라인 이하), 반분리형(SemiDetached, 30만 라인 이하), 내장형(Embedded, 30만 라인 이상)
    2. PUTNAM : Rayleigh-Norden, SLIM
    3. FP : ESTIMACS 사용
        - 내부논리파일, 외부논리파일 | 외부입력, 외부출력, 외부조회
### 일정 산정
1. 작업 분해 WBS
2. PERT/CPM 네트워크 
3. 임계 경로, 최소 소요 시간 계산
4. 소요 M/M, 기간 산정
5. 간트 차트

## 요구사항 분석
### 현행 시스템 분석
- CPND (유튜브 생각) : Contents, Platform, Network, Device 
- 운영체제, 네트워크, DBMS, 미들웨어 분석
    - 미들웨어 : 양쪽 연결하여 데이터 주고받을 수 있도록 중간에서 매개 역할하는 SW
    - 미들웨어 종류 
        1. 원격프로시저 - RPC, 원격에서 동작하는 프로시저 호출
        2. 메시지지향 - 메시지 저장하면서 다른 업무 지속할 수 있게하는 비동기식 미들웨어
        3. ORB - 객체 및 서비스 요청 및 전송 가능
        4. DB 접속 - APP ~ DATA 연결
        5. TP 모니터 - 분산 시스템 APP을 지원 
        6. WAS - 웹 애플리케이션 지원
        7. 엔터프라이즈 서비스 버스 - 기업 안팎에 있는 모든 시스템 환경 연동
### 요구공학
- 요구사항 개발 프로세스 : 도 분 명 확 (도출 분석 명세화 확인)
    - 확인(Validation) : 분석가가 요구사항을 이해했는지
    - 검증(Verification) : 요구사항 문서가 일관성있고 안전한지
- 요구사항 분석 도구 : 상위 하위 통합 
- HIPO : 하향식 소프트웨어 개발 문서화 도구 
    - HIPO Chart 종류 : 가시적 도표, 총체적 도표, 세부적 도표 
### 요구사항 분석 모델링
- 모델링 구분 : 기능적(사용자 관점 시스템 기능), 정적(시스템 구조), 동적(시스템 동작) 
- 구조적 분석 도구
    1. 자료 흐름도 (DFD)
    2. 자료 사전 (DD)
    3. 소단위 명세서(Mini Spec) = 프로세스 명세서
    4. ERD 개체 속성 관계
    5. 상태 전이도 (STD)
- 객체 지향 분석 모델
    1. 럼바우 (객체-객체 다이어그램, 동적-상태 다이어그램, 기능-DFD)
    2. 부치, Jacobson, Coad-Yourdon, Wirfs-Brock
## 설계
## 소프트웨어 설계 
### 소프트웨어 설계
- 요구사항 명세서 바탕으로 소프트웨어의 구체적인 설계서 작성
- 종류
    - 상위 설계 : 아키텍처, 데이터, 인터페이스, 사용자 인터페이스
    - 하위 설계 : 모듈, 자료구조, 알고리즘 
- 설계 원리 : 분할과 정복, 추상화, 단계적 분해, 모듈화, 정보은닉, 결합도와 응집도 
- 구조와 기능을 그래픽적으로 표현 
### 소프트웨어 아키텍처
- 소프트웨어 기본구조, 시스템의 컴포넌트와 이들간의 관계를 기술
- 특징
    1. 간략성 : 이해하고 추론할 수 있는 수준의 간결함
    2. 추상화 : 시스템의 추상적인 표현 사용
    3. 가시성 : 시스템이 포함해야하는 요소 명확히 가시화
    4. 관점 모형 : 이해당사자들의 관심사에 따른 모형 제시 → 4+1 뷰
    5. 의사소통 수단
- 4+1 뷰
    1. 논리 뷰 : 설계자 관점
    2. 구현 뷰 : 개발자 관점
    3. 프로세스 뷰 : 시스템 통합자 관점
    4. 배치 뷰 : 시스템 엔지니어 관점
    5. 유스케이스 뷰 : 아키텍처 설계 및 검증 주도
- 품질 속성 : 정확성, 신뢰성, 효율성, 무결성, 사용 용이성, 유지보수성, 시험 용이성, 유연성, 이식성, 재사용성, 상호 운용성, 확장성, 보안
- 소프트웨어 아키텍처 패턴 : 재사용 가능한 소프트웨어 아키텍처의 해결책
    1. 계층화 : 여러 계층으로 구분, 각 계층은 하위 계층의 기능 사용
    2. 클라이언트-서버 : 서버가 여러 클라이언트에 서비스 제공
    3. 마스터-슬레이브 : 작업을 여러 슬레이브에 분산시키고, 결과를 종합
    4. 파이프-필터 : 데이터 스트림에서 필터 컴포넌트가 각 단계의 처리를 수행하고 파이프를 통해 결과를 전달
    5. 브로커 : 분산 시스템에서 컴포넌트 간의 통신을 중재하는 브로커 컴포넌트 사용
    6. 피어 투 피어 : 모든 피어가 서버와 클라이언트의 역할 동시 수행
    7. 이벤트 버스 : 이벤트 버스를 통해 메시지 발생
    8. 모델-뷰-컨트롤러 : M(데이터 처리)-V(사용자 인터페이스)-C(입력 처리)
    9. 블랙보드 : 복잡하고 명확한 해결 전략이 정의되지 않은 문제에 사용
    10. 인터프리터 : 특정 프로그래밍 언어의 해석과 실행을 위한 컴포넌트 설계에 사용
### UML
- 소프트웨어 시스템 시각화 및 문서화, 구조와 동작 명세하는 모델링 `언어` | 가시화, 명세화, 구축, 문서화
- 구성요소
    - 사물 : 구조, 행동, 그룹, 주해
    - 관계 
        1. 일반화 : 부모-자식 클래스, 상속 관계
        2. 연관 : 2개 이상의 사물이 서로 관련
        3. 의존 : 연관관계와 비슷, 두 클래스의 관계가 한 메서드를 실행하는 동아과 같이 매우 짧은 시간만 유지된다는 차이
        4. 실체화 : 인터페이스 구현 받아 추상 메서드 오버라이딩
        5. 집합-집약 : 한 객체가 다른 객체 소유하는 `has a` 관계
        6. 집합-합성 : 부분 객체가 전체 객체에 속하는 긴밀한 관계
- 다이어그램
    - 구조 다이어그램
        1. 클래스 : 시스템의 클래스들과 그들 간의 관계
        2. 객체 : 시스템 내 객체와 관계
        3. 컴포넌트 : 시스템 구성 요소들과 그들 간의 인터페이스 표현
        4. 배치 : 시스템의 물리적 배치와 구성요소들 간의 관계를 표현
        5. 복합체 구조 : 시스템 내의 복합 구조
        6. 패키지 : 시스템의 패키지나 이들 간의 관계
    - 행위 다이어그램
        1. 유스케이스 :  시스템의 기능과 사용자 간의 상호작용 (시스템, 액터, 유스케이스)
            - 연관관계 -
            - 포함관계 <<`Include`>>
            - 확장관계 <<`extend`>>
            - 일반화관계 
        2. 시퀀스 : 객체 간의 상호작용을 시간 순서에 따라 표현
        3. 커뮤니케이션 : 객체 간의 상호작용과 통신
        4. 상태 : 객체의 생명주기 동안의 상태 변화 표현
        5. 상호작용 : 시스템의 상호작용을 하나의 고수준 워크플로우로 표현
        6. 활동 : 시스템의 프로세스 또는 워크플로우
        7. 타이밍 : 객체의 행동과 시간에 따른 상호작용
## 화면 설계
### UI 설계
- UI : 기기와 사용자 간의 상호작용을 가능하게 하는 매개체
- UX : 사용자가 UI를 통해 경험하는 모든 것
- 원칙 : 직 유 학 유
    - 직관성 : 누구나 쉽게 이해하고 사용
    - 유효성 : 사용자의 목적 정확하게 달성
    - 학습성 : 누구나 쉽게 배우고 익힌다
    - 유연성 : 사용자의 요구사항 최대한 수용, 오류 최소화
- 설계 도구 : 와이어프레임, 스토리보드, 프로토타입, 목업, 유스케이스
### UI 구현
- HTML (구조), CSS (디자인), Javascript (동적)
- AJAX : 비동기 웹 개발 프레임워크, 웹 페이지의 일부만 독립적으로 업데이트 가능

## 구현
## 서버 프로그램 구현
### 개발 환경 구축
1. 서버 환경 구축
    1. 웹 서버 : 클라이언트에 정적 파일 제공하는 서버 ex. 아파치
    2. 웹 애플리케이션 서버(WAS) : 동적인 웹 서비스 제공하는 서버 ex. 톰캣
    3. 데이터베이스 서버 (DBMS) ex. Oracle, MySQL
    4. 파일서버 : 사용자 파일을 저장하고 공유하는데 사용되는 서버 
    5. 로드밸런서 : 여러 대의 서버가 있을 때, 이들 네트워크 효율적으로 분배하는 장치
    6. CDN : 대용량 콘텐츠 빠르게 제공하기 위해, 물리적으로 가까이 있는 곳에 있는 서버 네트워크 사용
    7. 시스템 아키텍처 고려사항 : 확장성, 성능, 응답 시간, 처리량, 접근성, 일관성, 보안 
2. 개발 소프트웨어 환경
    1. 시스템 소프트웨어
        1. 운영체제 : 하드웨어 운영 관리, 시스템 자원 관리
        2. JVM : 자바 관련 프로그램 실행하기 위한 환경 제공
        3. 웹 서버 : 정적 웹 서버 제공 미들웨어
        4. WAS : 동적 웹 서비스 제공 미들웨어
        5. DBMS 
    2. 개발 소프트웨어
        1. 요구사항 관리 도구
        2. 설계/모델링 도구 : UML 지원, 데이터베이스 설계
        3. 구현 도구 : 코드 개발 ex. Intellij, Eclipse
            - IDE : 코딩, 디버깅, 컴파일, 배포 통합 처리
            - 적정성, 효율성, 이식성, 친밀성, 범용성
        4. 테스트 도구 : 개발된게 요구사항에 부합하는지 테스트
        5. 형상관리 도구 : 소스 코드와 문서 등의 변경 사항 버전별로 관리 Git(분산 저장소), SVN(중앙 통제 방식)
            - 형상 관리 절차 ( 식 통 감 기 )
                1. 형상 식별 : 관리해야 할 항목 구분, 번호나 태그 부여
                2. 형상 통제 : 형상 통제 위원회의 승인을 통한 변경 통제 이뤄짐
                3. 형상 감사 : 변경이 계획에 따라 적절하게 이뤄졌는지 검토
                4. 형상 기록/보고 : 변경 사항과 처리 과정을 기록, 보고
        6. 협업 도구 : 팀원 간의 소통
        7. 배포 도구 : 소프트웨어 빌드, 테스트, 배포 자동화 도구
            - 빌드 도구 : 실행 가능한 소프트웨어로 변경하는 일련의 과정
### 개발 프레임워크
- 소프트웨어 개발에 필요한 공통적인 구성요소와 아키텍처를 일반화하여 제공하는 반제품 형태의 소프트웨어
- 프레임워크 특징
    - 모듈화 : 캡슐화를 통한 모듈화 강화
    - 재사용성 : 여러 애플리케이션에서 반복적으로 사용할 수 있는
    - 확장성 : 다형성을 활용
    - 제어의 역흐름
- 라이브러리 : 자주 사용되는 루틴이나 리소스를 모아 놓은 것
- API : OS나 프로그래밍 언어가 제공하는 기능을 APP에서 사용할 수 있도록 만든 인터페이스
### 모듈 구현
- 단위 모듈 설계의 원리 : 단계적 분해, 추상화, 독립성, 정보 은닉, 분할과 정복
- 결합도 (Coupling) : 낮을수록 좋음 // 데이터가 제일 좋음
    - 데이터(Data) : 모듈 간 인터페이스로 값만 전달
    - 스탬프(Stamp) : 모듈 간 인터페이스로 배열, 오브젝트 등이 전달, 동일한 자료구조 조회
    - 제어(Control) : 값만 전달하는게 아니라 어떻게 처리할지 제어 요소까지 전달
    - 외부(External) : 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조
    - 공통(Common) : 모듈 밖에 선언되어 있는 전역변수 참조
    - 내용(Content) : 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용
- 응집도 (Cohesion) : 높을수록 좋음 // 기능적이 제일 좋음
    - 우연적(Coincidental) : 모듈 내부의 각 구성요소들이 연과 없음
    - 논리적(Logical) : 유사한 성격이거나 특정 형태로 분류
    - 시간적(Temporal) : 특정 시간에 처리되어야 하는 활동들
    - 절차적(Procedural) : 다수의 관련 기능을 가진 모듈 내에서 순차적으로 수행
    - 통신적(Communication) : 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여
    - 순차적(Sequential) : 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우
    - 기능적(Functional) : 모듈 내부 모든 기능이 단일 목적 수행
- 팬인-팬아웃
- 공통 모듈 구현 
    - 구현 요소
        1. DTO : 프로세스 사이에서 데이터 전송, Getter | Setter
        2. VO : 도메인에서 속성들을 묶어 특정 값을 나타내는 객체
        3. DAO : 실질적으로 DB에 접근
        4. Service : DAO 클래스 호출 객체
        5. Controller : 비즈니스 로직 수행하는 객체
### 서버 프로그램 구현
- DBMS 접속기술 : 소켓통신, VendorAPI, JDBC, ODBC
- ORM 프레임워크
- 시큐어 코딩 
    1. OWASP
    2. 시큐어 코딩 가이드 : SQL Injection, XSS, 자원 삽입, 위험한 형식 파일 업로드, 명령 삽입, 메모리 버퍼 오버플로

### 배치 프로그램 구현
- 데이터를 일괄적으로 모아서 처리하는 대량의 작업
- 스케줄 관리 도구 : 크론탭, 

## 인터페이스 구현
### 인터페이스 개요
- 서로 다른 시스템이나 장치 간에 정보나 신호를 주고받을 수 있게 도와주는 시스템
- 구성 : 송신 시스템 ~ 중계 시스템 ~ 수신 시스템
- 송수신 데이터 식별 : 송수신 시스템 간에 전송되는 표준 항목, 업무 처리용 데이터, 공통 코드 정보 등을 누락 없이 식별하고 `인터페이스 명세서` 작성
  - 송수신 전문 구성
    - 전문 공통부 : 인터페이스 표준 항목 포함
    - 전문 개별부 : 업무처리에 필요한 데이터 포함
    - 전문 종료부 : 전송 데이터의 끝을 표시하는 문자 포함
### 인터페이스 설계서
- 인터페이스 목록 : 사용할 인터페이스들을 쭉 적은 것
  - 연계 업무와 연계에 참여하는 송수신 시스템의 정보, 연계 방식과 통신 유형 등에 대한 정보
- 인터페이스 정의서 : 인터페이스 상세 내용
  - 데이터 송신 시스템과 수신 시스템 간의 속성과 제약조건 등을 상세히 포함
### 인터페이스 기능 구현
- 내외부 모듈 연계 방식
  1. EAI (Enterprise Application Integration)
    - 기업 내의 다른 플랫폼 및 애플리케이션들을 연결, 통합하는 솔루션⌐
    - 비즈니스 통합 및 연계성 증대, 시스템 확장성 향상
    - 구축 유형
      1. Point to Point : 미들웨어 없이 직접 애플리케이션 연결
      2. Hub & Spoke : 중앙 허브를 통한 중앙 집중적 연결 방식, 확장 및 유지 보수 용이
      3. Message Bus : 미들웨어를 사용하여 애플리케이션 사이에서 메시지를 전달, 뛰어난 확장성, 대용량 처리 가능
      4. Hybrid : 내부적으로는 hub&Spoke, 외부적으로는 Message Bus 
  2. ESB (Enterprise Service Bus)
     - 웹 서비스 중심의 표준화된 데이터 버스를 이용하여 다양한 애플리케이션을 유연하게 통합하는 플랫폼 → 서비스 중심 통합 지향
- 인터페이스 연계 기술
  1. DB Link : DB에서 제공하는 DB Link 객체 사용, 수신 시스템에서 DB Link 생성하고 송신에서 직접 참조  
  2. DB Connection : 수신 시스템의 was에서 송신 시스템 db로 연결하는 DB Connection Pool을 생성하고 연계 프로그램에서 해당 DB Connection Pool 명을 이용
  3. JDBC : 수신 시스템의 프로그램에서 JDBC 드라이버를 이용해 송신 시스템 DB와 연결
  4. API / OpenAPI 
  5. Web Service : WSDL, UDDI, SOAP 프로토콜을 이용해 연계
  6. Hyper Link 
  7. Socket : 소켓 생성해 포트 할당 받고 클라이언트 통신 요청으로 연결
- 인터페이스 전송 데이터
  1. JSON : Javascript 객체 문법 기반
  2. XML : 웹에서 구조화한 문서를 표현하고 전송하도록 설계한 마크업 언어
  3. YAML : 데이터 직렬화 언어
  4. CSV : 쉼표로 구분한 텍스트 데이터 
- 인터페이스 구현
  1. AJAX : 비동기 데이터 교환, 전체 페이지를 새로고침하지 않고, 페이지의 일부만을 변경할 수 있는 기법
  2. SOAP : XML 기반 메시지 교환 프로토콜
     - SOAP 구성
       1. SOAP : XML 기반 메시지를 네트워크상에서 교환하는 프로토콜 
       2. UDDI : 비즈니스 업체 목록 등록을 위한 XML 규격 ( 설명서의 모음 )
       3. WSDL : 서비스의 기술적 세부사항 기술 ( 설명서 )
     - 보안 프로토콜
       1. SAML : 인증 권한 관리
       2. XKML : 키 관리
       3. XACML : 접근 제어 
  3. REST : HTTP METHOD를 통한 CRUD Operation 적용
     - REST 구성 요소
       1. 자원 : URI 를 통해 식별되는 서버의 데이터
       2. 행위 : (R)GET (C)POST (U)PUT (D)DELETE 등의 메서드
       3. 표현 : JSON, XML, TEXT 등 다양한 형태로 
     - RESTful : 레스트 원리를 따른 시스템 
- 인터페이스 보안
  - 보안 취약점 분석 : 인터페이스를 통한 데이터 변조, 탈취 
    - 패킷 공격 기법
      - 스니핑 : 네트워크상에서 전송되는 패킷을 가로채는 행위
      - 스푸핑 : IP 주소나 다른 식별자를 위장하여 다른 사용자나 시스템으로 속이는 행위
  - 인터페이스 보안 기능 적용
    1. 네트워크 영역 : 스니핑 등의 위협 방지 위해 네트워크 트래픽에 대한 암호화 설정 - IPSec, SSL, S-HTTP, TLS
    2. 애플리케이션 영역 : 시큐어코딩 가이드를 참조해 코드상 보안 취약점을 보완하는 방향으로 보안 가능
    3. DB 영역 : 민감 데이터 암호화, 익명화 등을 통한 데이터 자체 보안
### 인터페이스 구현 검증
- 인터페이스 구현 검증 도구
  1. xUnit : 다양한 언어를 지원
  2. STAF : 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원
  3. FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과
  4. NTAF : FitNesse, STAF의 장점 통합
  5. Selenium : 다양한 브라우저 및 개발 언어를 지원
  6. watir : Ruby 사용 애플리케이션 테스트 프레임워크
- 인터페이스 구현 감시 도구 : APM으로 동작 상태 감시, 스카우터*제니퍼 로 정보 조회 분석 시각화
## 객체지향 구현
### 객체지향 설계
- 객체지향 : 현실 세계의 유형, 무형의 모든 대상을 객체로 나누고, 객체의 행동(Method)과 고유한 값(Attribute)을 정의하여 설계하는 기법
- 구성요소
  - 클래스 : 속성과 연산을 정의해 만든 메모리 상에 올라가지 않는 틀 
  - 객체 : 클래스의 인스턴스
  - 속성 : 객체들이 가지고 있는 고유한 데이터
  - 메서드 : 작업을 수행하기 위한 명령문의 집합
  - 메시지 : 객체에게 어떤 행위를 하도록 지시
- 객체지향 언어의 특징
  - 캡슐화 : 속성과 메서드를 하나로 묶은 것
  - 정보은닉 : 내부 데이터에 직접 접근할 수 없도록 제한
  - 상속 : 상위 클래스의 속성과 메서드를 하위 클래스가 물려받음
  - 다형성 : 하나의 메시지에 대해 여러 가지 방법으로 응답 
    → 오버로딩(속성|매서드 변화), 오버라이딩(상속 관계)
  - 추상화 : 실체의 핵심적인 개념만을 추출
- 객체지향 설계원칙 (SOLID)
  - 단일 책임 원칙(SRP) : 한 클래스는 하나의 책임만을 가져야 한다.
  - 개방폐쇄원칙(OCP): 확장에열려있고, 수정에 닫혀 있어야 한다.
  - 리스코프 치환 원칙(LSP) : 자식 클래스는 언제나 자신의 부모 클래스를 대체 
  - 인터페이스 분리 원칙(ISP) : 사용하지 않는 인터페이스는 구현하지 말아야 한다. 
  - 의존성역전원칙(DIP):변화가 거의 없는 것에 의존
- 디자인 패턴 : 자주 발생하는 문제들에 대해 재사용할 수 있도록 만들어놓은 패턴들의 모음
  - 생성 패턴 : 객체 생성과 관련한 패턴 (생빌프로팩앱싱)
    - Builder
    - Prototype
    - Factory Method
    - Abstract Factory
    - Singleton
  - 구조 패턴 : 객체를 조합해서 더 큰 구조를 만드는 패턴 (구브데퍼플프록컴어)
    - Bridge
    - Decorator
    - Facade
    - Flyweight
    - Proxy
    - Composite
    - Adapter
  - 행위 패턴 : 알고리즘이나 책임 분배에 관련된 패턴
    - Chain of Responsibility
    - Command
    - Interpreter
    - Iterator
    - Mediator
    - Memento
    - Observer
    - State
    - Strategy
    - Template Method
    - Visitor
## 테스트 (애플리케이션 테스트 관리)
### 애플리케이션 테스트케이스 설계
- 소프트웨어 테스트 : 결함을 발견하기 위한 절차와 행위
  - 필요성 : 오류 발견 관점, 오류 예방 관점, 품질 향상 관점
  - 기본 원칙
    - 결함 집중 (파레토의 법칙) : 20%의 코드에서 80%의 오류가 발생한다
    - 살충제 패러독스 : 반복적인 테스트로는 새로운 결함을 찾기 어렵다
    - 오류-부재의 궤변 : 오류가 없다고 해도 사용자의 요구사항을 충족하지 못하면 품질이 좋다고 할 수 없다
  - 테스트 산출물 : 테스트 계획서, 테스트 케이스, 테스트 시나리오, 테스트 결과서
- 테스트 오라클 : 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동
  - 유형 (참 샘 휴 일)
    1. 참 오라클 : 모든 입력값에 대해 결과 생성 
    2. 샘플링 오라클 : 제한된 입력 값들에 대해서만 결과 제공
    3. 휴리스틱 오라클 : 추정 결과를 제공하는 오라클
    4. 일관성 검사 오라클 : 변경 전후로 테스트 결과의 일관성을 검증하는 오라클
- 테스트 레벨 : V 레벨 ( 단 통 시 인 )
  - 단위 테스트 : 개별 소프트웨어 모듈 또는 구성요소의 기능적, 비기능적 측면을 검사 | 주로 개발자가 진행하는 정적, 동적 테스트
  - 통합 테스트 : 여러 모듈 또는 서브시스템을 통합, 그 사이의 인터페이스 및 상호작용을 검증 | 상향, 하향, 빅뱅, 백본
  - 시스템 테스트 : 통합된 소프트웨어 대상, 기능, 비기능 테스트 진행 
  - 인수 테스트 : 시스템 배포하거나 사용자가 요구분석 명세서에 명시된 사항을 충분히 만족하는지 판정 | 알파 테스트(개발자의 통제 하에), 베타 테스트(사용자들이~)
- 소프트웨어 테스트 기법 
  1. 프로그램 실행 여부 
     - 정적 테스트 : 동작시키지 않고, 내부를 보는 것 | 코드검사, 워크스루, 인스펙션
     - 동적 테스트 : 동작시키면서 문제점 찾기
  2. 테스트 기법 
     - 화이트 박스 테스트 : 소프트웨어 내부 구조와 동작 중점
       - 문장 검증 : 모든 문장 한 번 수행
       - 선택(분기) 검증 : 선택하는 부분만 검증
       - 경로 검증 : 수행 가능한 모든 경로 검사
       - 조건 검증 : 조건이나 반복문 내 조건식 검사 
       - 기초 경로 검사 : V(G) = E - N + 2
     - 블랙박스 테스트 : 프로그램의 사용자 요구사항 명세를 보면서 테스트 ( 동 경 원 오 비 상 )
       - 동등 분할 기법 : 입력 자료에 초점 맞춰 테스트
       - 경계값 분석 : 경계값을 테스트 케이스로 선정
       - 원안-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황분석
       - 오류 예측 검사 : 과거의 경험이나 테스터의 감각으로 테스트
       - 비교 검사 : 여러 버전의 프로그램에 동일한 자료를 제공
       - 상태전이 검사 : 상태를 변화시키는 이벤트와 입력값을 파악 
  3. 테스트에 대한 시각
     - 검증 (Verification) : SW 개발 과정을 테스트
     - 확인 (Validation) : SW 결과를 테스트
  4. 테스트 목적 
     - 회복 : 고의적으로 실패 유도
     - 안전 : 보안적인 결함 점검
     - 강도 : 과부화 테스트
     - 성능 : 응답하는 시간, 처리량, 반응 속도 등
     - 구조 : 소스코드의 복잡도 평가
     - 회귀 : 변경 코드에 대해 새로운 결함 여부 평가
     - 병행 : 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 비교
     - A/B : 기존 서비스 대비 효과 
     - 스모크 : 테스트 환경의 테스트
  5. 테스트 종류 : 명세 기반 테스트, 구조 기반 테스트, 경험 기반 테스트 (경험이 많은 사용자가 하는 테스트, 딴 것들 보다 상대적으로 시간이 적게 걸려서 주로 이거 함)
- 테스트 커버리지 : 테스트를 얼마나 수행했는지 측정하는 기준  ( 기 라 코 )
  - 기능 기반 : 기능을 모수로 
  - 라인 기반 : 라인 수를 모수로
  - 코드 기반 : 소스 코드의 구문, 조건, 결정 등을 측정 ( 구 조 결  조 변 다 )
    1. 구문 : 모든 구문 한 번 이상 수행
    2. 조건 : 결정 포인트 내의 ~~ 모든 개별 조건식 수행
    3. 결정 : 모든 분기문에 대해 수행
    4. 조건/결정 : 결정 포인트, 개별 조건식 모두 T/F 가져야
    5. 변경 조건/결정 : 모든 결정 포인트 내의 개별 조건식은 적어도 한 번 T/F
    6. 다중 조건 : 가능한 조합 모두
### 애플리케이션 통합 테스트
- 결함관리 도구 : 테스트 수행 후 발생한 결함을 추적하고 관리할 수 있게 해주는 도구
  - 프로세스 
    에러 발견 → 에러 등록 → 에러 분석 → 결함 확정 → 결함 할당 → 결함 조치 → 결함 조치 검토 및 승인
  - 결함 추이 분석 : 발견된 결함의 결함 관리 측정 지표의 속성 값들 분석, 향후 어떤 모듈 또는 컴포넌트에서 결함이 발생할지 예측하는 작업
  - 결함 측정 지표 : 결함 분포, 결함 추세, 결함 에이징
- 테스트 자동화 도구 : 반복적인 테스트 작업을 자동화
  - 유형
    1. 정적 분석 도구 : 실행하지 않고 분석 
    2. 테스트 실행 도구 : 사전에 작성된 스크립트나 시나리오 실행
    3. 성능 테스트 도구 : 시스템의 성능, 부하, 스트레스 테스트
    4. 테스트 통제 도구 : 테스트의 전체 프로세스 관리 도구
    5. 테스트 장치 : 드라이버(상향식), 스텁(하향식), 슈트(테스트 케이스 집합), 케이스(입력값, 실행 조건, 기대 결과)
- 통합 테스트 : 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내는 테스트 기법 
  - 점증적 방식 : 상향식, 하향식 
  - 비 점증적 방식 : 빅뱅(모든 구성요소 한꺼번에 통합해 테스트, 소규모에 용이)
### 애플리케이션 성능 개선
1. 애플리케이션 성능 저하 원인
   - DB 관련 성능 저하 
     - DB Lock : 대량의 데이터 조회나 과도한 업데이트 시 발생
     - 불필요한 DB Fetch : 결과 세트에서 커서를 자주 옮기는 경우 
     - 연결 누수 : DB 연결 후, 이를 제대로 반환하지 않을 때 발생
   - 내부 로직으로 인한 성능 저하 원인
     - 파일 관련 오류 : 대량의 파일 업로드하거나 다운로드 하는 과정에서 발생
     - 코드 오류 
   - 외부 호출로 인한 성능 저하 
2. 애플리케이션 성능 분석
   - 성능 분석 지표 : 처리량, 응답 시간, 경과 시간, 자원 사용률 
   - 성능 분석 도구 : JMeter, LoadUI, OpenSTA
   - 모니터링 도구 : Scouter, NMon, Zabbiz, Jennifer
3. 정형 기술 검토회의(FTR) : 소프트웨어 품질 보증 활동 (오류 발견 목적)
4. 소스코드 품질 분석 : 이걸로 결함 발견되면 → 리팩토링 진행
   - 동료검토
   - 워크스루 : 계획된 개발자 검토 회의
   - 인스펙션 : 작업자가 아닌 전문가나 팀이 검사해 오류 찾아내기
5. 소스코드 품질 분석 도구
   - 정적 분석 도구, 동적 분석 도구(Avalanche, Valgrind)
6. 애플리케이션 성능 개선하기
   - 코드 최적화 : 알고리즘 개선, 병목 현상 제거, 실행 시간 단축, 메모리 사용 최소화
   - 코드 스멜 : 잠재적인 문제점
     - 스파게티 코드 : 난잡한 코드
     - 외계인 코드 : 오래되어 유지보수가 어려운 코드 
   - 리팩토링 : 외부 동작 변경 없이 내부 구조를 개선하는 방법 
   - 클린코드 : 의존성 최소화, 명확한 가독성과 목적성을 가진 코드 
     - 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화
     
## 유지보수
### 소프트웨어 유지보수
- 개념 : 개발 완료 이후부터 폐기까지 지속적으로 수행되는 작업
  → 이를 위해서 동료검토, 워크스루, 인스펙션 (품질분석) 해서 ~ 리팩토링 ~ 클린코드 만들어야 함!!
- 유지보수의 구분
  - 수정 보수 : 오류 수정
  - 적응 보수 : 환경 변화
  - 향상 보수 : 기능 추가
  - 예방 보수 : 잠재적 오류 대비
- 관련 용어
  - 레거시 시스템 : 오래된 기술, 컴퓨터 시스템~
  - 외계인 코드 : 오래되어 유지보수가 어려운 코드
  - 스파게티 코드 : 복잡하게 얽힌 프로그래밍 소스코드
  - 코드 스멜 : 소스코드 내에 존재하는, 잠재적인 문제
  
## 제품 소프트웨어 패키징
### 국제 표준 제품 품질 특성
- 제품 품질 국제 표준 : 제품이 사용자 요구를 만족하는지 검증
  - ISO/IEC 9126 (기 신 사 효 유 이)
    - 기능성 : 명시 및 내재된 요구사항 만족하는 소프트웨어 기능
    - 신뢰성 : 성능 수준 유지할 수 있는 능력
    - 사용성 : 사용자에 의한 이해, 학습, 사용 및 선호되는 능력
    - 효율성 : 자원 사용량에 따른 성능 제공 능력
    - 유지보수성 : 소프트웨어 변경 능력
    - 이식성 : 다른 환경으로 이전 능력
  - ISO/IEC 14598
    - 반복성 : 동일 평가자가 동일 제품 테스트
    - 재현성 : 다른 평가자가 동일 제품 테스트
    - 공정성 : 평가의 편향 없음
    - 객관성 : 평가자의 주관성에 영향 받지 않는 평가
  - ISO/IEC 12119 
  - ISO/IEC 25000 
- 프로세스 품질 국제 표준
  - ISO/IEC 12207
    - 기본 생명주기 프로세스 : 개발절차
    - 지원 생명주기 프로세스
    - 조직 생명주기 프로세스
  - ISO/IEC 15504 (SPICE) : 표준 프로세스
  - CMM : 소프트웨어 개발 업체들의 업무능력 평가 기준 평가 모형
    - 성숙도 5단계 : 초기 → 반복 → 정의 → 관리 → 최적화
  - CMMI : 기존 CMM에 PM, Procurement, 시스템 엔지니어링 요소 추가 
    - 성숙도 5단계 : 초기 → 반복 → 정의 → 정량적 관리 → 최적화
- 서비스 관리 국제 표준 
  - ISO/IEC 20000 : 고객에게 제공하는 IT 서비스의 수준을 객관적 평가
### 제품 소프트웨어 패키징
- 애플리케이션 패키징 : 개발된 소프트웨어를 사용자에게 전달하기 위한 형태로 패키징하는 과정 
- 애플리케이션 배포 도구 : 최종 사용자에게 소프트웨어를 전달하는 전체 과정
  - CI : 지속적인 통합
  - CD : 지속적인 서비스 제공, 지속적인 배포
- 릴리즈 노트 : Header, 개요, 목적, 이슈, 수정/개선 내용 등 함께 배포되는 문서
- DRM : 불법 사용을 제한하고, 승인된 사용자에게만 콘텐츠 사용을 허용하는 기술 (영화 배급사 생각)
  - 저작권 보호 기술 : 암호화 기술, 위변조 방식, 워터마킹
### 제품 소프트웨어 매뉴얼 작성 
- 사용자가 제품을 처음 설치할 때 참조하는 매뉴얼